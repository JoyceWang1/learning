# RE
[TOC]()
---
> 几个工具
> - [https://regexper.com/][2]
> -  [https://regex101.com/][3]

## 元字符

|元字符|描述|
|:----:|----|
|`·`|句号匹配任意单个字符除了换行符.|
|`[]`|字符种类. 匹配方括号内的任意字符.|
| `[^ ]`|否定的字符种类. 匹配除了方括号里的任意字符|
|`*`|匹配\>=0个重复的在\*号之前的字符.|
|`+`|匹配\>1个重复的+号前的字符.
|`?` |标记?之前的字符为可选.|
|`{n,m}`|匹配num个中括号之前的字符 (n \<= num \<= m).|
| `(xyz)`|字符集, 匹配与 xyz 完全相等的字符串.|
|`&#124;`|或运算符,匹配符号前或后的字符.|
|`&#92;`|转义字符,用于匹配一些保留的字符 `<code>[ ] ( ) { } . * + ? ^ $ \ &#124;</code>`|
|`^`|从开始行开始匹配.|
|`$`|从末端开始匹配.|

## 操作元：被操作的对象
### 本义字符： `a-zA-Z0-9_`
表示自己，单个字符，一共63个
### 转义字符：`\`
用于指定`{ } [ ] / \ + * . $ ^ | ?`的本意义
### 集合原子： `[]`
> 集合原子，还是原子！
用`[]`指定一个字符集，标识**集合原子**，在其中使用连字符指定字符集的范围，`[]`中部关心顺序！可以包含：
- `-` 区间
- `^`非，否定字符集。注意：只能使用一次，且跟在`[`后面，否则失效！
- `[]`中的 `|  ()` 都是符号本身，而不是或和分组的含义

### 类别原子：`代表一类 \d \w \s .`
 类别原子指能代表某一类字符的原子，需要使用转义字符和另外一个符号来表示。主要有如下几种
- `.` ：元字符中最简单的例子，匹配除了`\r \n`以外的** 任意单个字符**
- `\d`：**任意数字**，等价于`[0-9]`
- `\D`：**任意非数字**，等价于`[^0-9]`
- `\w`：**任意本意字符**，等价于`[0-9a-zA-Z_]`
- `\W`：**任意非本意字符**，等价于`[^0-9a-zA-Z_]`
- `\s`：**任意空白**，等价于`[ \f\n\r\t\v]` (第一个是空格)
	- `\f` 分页符
	- `\n \r`换行符
	- `\t`制表符
	- `\v`纵向制表符
- `\S`：**任意非空白**，等价于`[^ \f\n\r\t\v]` (第一个是空格)
### 边界原子（锚点）：`^ $ \b \B`
指定原子的位置锚点符号
- `^` 匹配原子是否在字符串的开头
- `$` 匹配原子是否在字符串的结尾
- `\b` 单词边界
	- `er\b`  匹配 coder 中的 er，不能匹配 error 中的 er
	- `er\B` 与`er\b`相反
- `\B` 非单词边界
注意：`^$`在 python 分别可以被`\A \Z`替代
### 组合原子：`()`
`()` 有2个作用：组合和捕获（\_后面讲\_）
- 组合：表示将多个单子符组合成**一个原子**
	- `(ab)*` ab连续出现或0或更多次
	- `(a|b|c)ed`也可以使用`|`   可以匹配`aed bed ced`
- 捕获：后面讲
## 操作符：操作的动作
### 数量操作符（量词）：`+ ? * {m,n}`
用来限定前面**原子**的出现次数，如果没有限定，默认出现且只出现一次。
_数量操作符在与`[]`一起使用时，一定要放下`[]`的后面外面_
- `+` 匹配之前原子出现次数`>=1`
	- `c.+t` 以 c 开头 t 结尾，中间跟任意个字符
	- `go+gle` gogle google gooogle
- `*` 匹配之前原子出现次数`>=0`
	- `[a-z]*` 以1个小写字母开头，后面的所有字母
	- `.*` 匹配至少一个字符的所有字符
	- `\s*cat\s*`0个或多个空格开头和0个或更多个空格结尾的 cat 字符，**换句话说有没有空格都会匹配到**
	- `520*`匹配52，520，52000，52000...
- `?` 匹配之前原子为可选，且最多可以出现一次 `=0 or =1`
	- `T?he`匹配 The 或者 he
	- `colou?red` colored coloured
- `{m,n}`匹配之前原子可以重复出现的次数，最少 m 次 最多 n 次
	- `{n}` 之前原子出现 n次
	- `{n,}`之前原子至少 n 次
	- `[0-9]{2,3}`  匹配0-9的数字  `>=2 <=3` 即 2-3位
	-  `[0-9]{3}`  3位的0-9数字
### 或操作符：`|`
所有操作符中**优先级最低**的。`|`前后的原子在被数量操作符操作之后才操作`|`
- `begin|began|begun` 能匹配 `begin began begun` ，而不是`begibegabegun`
- 在集合原子`[]`中，各原子之间的关系只有或，相当于省略了成员之间的`|`，如：
- `[a|e]` 匹配 `a | e`3个字符，而不是 `a or e`
- 多说一句`[]`中的`()`也不是分组，而是`(` 和 `)`
### 匹配并捕获：`()  $1 $2`
使用`()`。括号中的值被暂存成一个带有索引的列表，第一个是`$1`第二个是`$2`，python中 `re.sub()`中被调用的值，索引的使用方法是`\1 \2`。
### 非捕获匹配：`(?:...)  ?: ?= ?! ?<= ?<! `
先行后发断言都属于非捕获匹配。之前见过的都是用来匹配文本，这前后预查（零宽度断言）用来标记匹配文本的位置。它包含的**匹配本身并不返回**，而是用于**确定正确的匹配位置**，它本身不是匹配结果的一部分。
举个例子比较好理解：在 html 页面中提取 head 标签里面的内容，但是不想要标签内容，如下内容中，只想要`<title>`标签内内的内容作为匹配项，但是不想要`<title>`标签
- 正确：`(?<=<title>).*(?=</title>)`，结果：` Hi,This is my RE Note`
- 错误：`<title>.*</title>`，结果：`<title> Hi,This is my RE Note</title>`
```html
<head>
	<title> Hi,This is my RE Note</title>
</head>
<body>
	<h1> Hi,This is my RE Note </h1>
</body>
```
- `(?:..)`只组合不捕获
- `(?=pattern)`正先行断言-**存在**，表示第一部分表达式之后一定跟着pattern定义的原子
- `(?!pattern)`负先行断言-**排除**，与?=相反
- `(?<=pattern)`正后发断言-**存在** ，表示第一部分表达式之前一定跟着pattern定义的原子
- `(?<!pattern)`负后发断言-**排除**，与?\<=相反
### 控制标记（标志）：`(?a) (?!) (?g) (?L) (?m) (?s) (?x)`
控制标记也叫模式修正符，可以修改表达式搜索的结果，可以任意组合使用。最长默认的是 i g 和 m。
- `i`忽略大小写，行内写法`(?i)`
- `g`全局搜索，找到第一个后不返回，行内写法`(?g)`
- `m`多行修饰符，当时用`^`和`$`时，会增加换行符之前和之后的位置
### 贪婪匹配和惰性匹配
默认使用贪婪模式（`+` 和`*`），会匹配尽量长的字串，使用`?`转换为惰性模式。
- `+` 懒惰版本`+?`
- `*` 懒惰版本`*?`
- `{n,}`懒惰版本`{n,}?`
### 回溯引用匹配
> 解决`<[H][1-6]>.*</[H][1-6]>`匹配到`<H2></H3>`的问题

回溯引用：允许正则表达式模式引用前面的匹配结果。后半部分引用前半部分定义的子表达式。\_可以想象成变量\_，只能引用被`()`圈起来的部分
`[ ]+(\w+)[ ]+\1`
- `[ ]+`  匹配一个或多个空格
- `(\w+)` 子表达式（组合原子）匹配一个或多个字母字符，`()`代表子表达式，这是一个整体，不是用来重复匹配，目的是把整个模式一部分单独划分出来便于后面引用
- `[ ]+` 匹配随后的空格
- `\1` 回溯引用，前面`(\w+)`匹配啥，这里引用啥，`\1`代表第一个`\2`代表第二个，`\0`代表整个表达式
**需要注意的是，不同语言语法对回溯引用支持有很大差别，需要查询后使用**

## 其他
这句话要牢牢记住：把必须匹配的的情况考虑周全并写出一个匹配结果符合预期的正则很容易，但把不需要匹配的情况也考虑进来，并确保他们将被排除在外要困难的多！
### 例子1：IP地址的匹配
> IP地址规则：`0.0.0.0~255.255.255.255`，详细规则：
> - 任何一个1位或2位的数字
> - 任何一个以1开头的三位数字
> - 任何一个以2开头、第二位数字在0-4之间的三位数字
> - 任何一个以25开头、第三位数字在0-5之间的三维数字

1. 版本1-匹配数字：`\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}`
	- 能匹配到数字，但是重复了三次
2. 版本2-去掉重复：`(\d{1,3}.){3}\d{1,3}`
	- 去掉了重复部分，但是789，999也被匹配出来
3. 版本3-去掉冗余匹配：`(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d{1,3})|(1\d{2})|(2[0-4]\d)|(25[0-5]))`
	- 原书：`(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))`
### 例子2：匹配 html 标签
> 匹配 html 里的标题 \<h1\>\</h1\> .. \<h6\>\</h6\\\>

```html
<BODY>
	<H1>welcome to my Homepage</H1>
	Content is divided into two sections:<BR>
	<H2>ColdFusion</H2>
	Information about Macromedia ColdFusion.
	<H2>Wireless</H2>
	Information about Bluetooth 802.11,and more.
	<H2>This is not valid HTML</H3>
</BODY>
```
1. 版本1-`<[Hh]1>.*</[Hh]1>`
	- 只匹配到H1的一级标题，但是 HTML有6级标题
2. 版本2-`<[Hh][1-6]>.*</[Hh][1-6]>`
	- 匹配到1-6级标题
3. 版本3-`<[Hh][1-6]>.*?</[Hh][1-6]>`
	- 调整贪婪匹配至懒惰型，避免从第一个H1一直匹配到最后一个H3
	- 并且把第八行的不合法标签也匹配到了`<H2></H3>`
4. 版本4-`<[Hh][1-6]>.*?</[Hh]\1>`
	- 使用回溯引用，解决 h2 h3问题

[2]:	https://regexper.com/
[3]:	https://regex101.com/