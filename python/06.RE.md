# RE
[TOC]()
---
> 几个工具
> - [https://regexper.com/][2]
> -  [https://regex101.com/][3]

## 元字符

|元字符|描述|
|:----:|----|
|`·`|句号匹配任意单个字符除了换行符.|
|`[]`|字符种类. 匹配方括号内的任意字符.|
| `[^ ]`|否定的字符种类. 匹配除了方括号里的任意字符|
|`*`|匹配\>=0个重复的在\*号之前的字符.|
|`+`|匹配\>1个重复的+号前的字符.
|`?` |标记?之前的字符为可选.|
|`{n,m}`|匹配num个中括号之前的字符 (n \<= num \<= m).|
| `(xyz)`|字符集, 匹配与 xyz 完全相等的字符串.|
|`&#124;`|或运算符,匹配符号前或后的字符.|
|`&#92;`|转义字符,用于匹配一些保留的字符 `<code>[ ] ( ) { } . * + ? ^ $ \ &#124;</code>`|
|`^`|从开始行开始匹配.|
|`$`|从末端开始匹配.|

## 操作元：被操作的对象
### 本义字符： `a-zA-Z0-9_`
表示自己，单个字符，一共63个
### 转义字符：`\`
用于指定`{ } [ ] / \ + * . $ ^ | ?`的本意义
### 集合原子： `[]`
> 集合原子，还是原子！
用`[]`指定一个字符集，标识**集合原子**，在其中使用连字符指定字符集的范围，`[]`中部关心顺序！可以包含：
- `-` 区间
- `^`非，否定字符集。注意：只能使用一次，且跟在`[`后面，否则失效！
- `[]`中的 `|  ()` 都是符号本身，而不是或和分组的含义

### 类别原子：`代表一类 \d \w \s .`
 类别原子指能代表某一类字符的原子，需要使用转义字符和另外一个符号来表示。主要有如下几种
- `.` ：元字符中最简单的例子，匹配除了`\r \n`以外的** 任意单个字符**
- `\d`：**任意数字**，等价于`[0-9]`
- `\D`：**任意非数字**，等价于`[^0-9]`
- `\w`：**任意本意字符**，等价于`[0-9a-zA-Z_]`
- `\W`：**任意非本意字符**，等价于`[^0-9a-zA-Z_]`
- `\s`：**任意空白**，等价于`[ \f\n\r\t\v]` (第一个是空格)
	- `\f` 分页符
	- `\n \r`换行符
	- `\t`制表符
	- `\v`纵向制表符
- `\S`：**任意非空白**，等价于`[^ \f\n\r\t\v]` (第一个是空格)
### 边界原子（锚点）：`^ $ \b \B`
指定原子的位置锚点符号
- `^` 匹配原子是否在字符串的开头
- `$` 匹配原子是否在字符串的结尾
- `\b` 单词边界
	- `er\b`  匹配 coder 中的 er，不能匹配 error 中的 er
	- `er\B` 与`er\b`相反
- `\B` 非单词边界
注意：`^$`在 python 分别可以被`\A \Z`替代
### 组合原子：`()`
`()` 有2个作用：组合和捕获（\_后面讲\_）
- 组合：表示将多个单子符组合成**一个原子**
	- `(ab)*` ab连续出现或0或更多次
	- `(a|b|c)ed`也可以使用`|`   可以匹配`aed bed ced`
- 捕获：后面讲
## 操作符：操作的动作
### 数量操作符（量词）：`+ ? * {m,n}`
用来限定前面**原子**的出现次数，如果没有限定，默认出现且只出现一次。
- `+` 匹配之前原子出现次数`>=1`
	- `c.+t` 以 c 开头 t 结尾，中间跟任意个字符
	- `go+gle` gogle google gooogle
- `*` 匹配之前原子出现次数`>=0`
	- `[a-z]*` 以1个小写字母开头，后面的所有字母
	- `.*` 匹配至少一个字符的所有字符
	- `\s*cat\s*`0个或多个空格开头和0个或更多个空格结尾的 cat 字符，**换句话说有没有空格都会匹配到**
	- `520*`匹配52，520，52000，52000...
- `?` 匹配之前原子为可选，且最多可以出现一次 `=0 or =1`
	- `T?he`匹配 The 或者 he
	- `colou?red` colored coloured
- `{m,n}`匹配之前原子可以重复出现的次数，最少 m 次 最多 n 次
	- `{n}` 之前原子出现 n次
	- `{n,}`之前原子至少 n 次
	- `[0-9]{2,3}`  匹配0-9的数字  `>=2 <=3` 即 2-3位
	-  `[0-9]{3}`  3位的0-9数字
### 或操作符：`|`
所有操作符中**优先级最低**的。`|`前后的原子在被数量操作符操作之后才操作`|`
- `begin|began|begun` 能匹配 `begin began begun` ，而不是`begibegabegun`
- 在集合原子`[]`中，各原子之间的关系只有或，相当于省略了成员之间的`|`，如：
- `[a|e]` 匹配 `a | e`3个字符，而不是 `a or e`
- 多说一句`[]`中的`()`也不是分组，而是`(` 和 `)`
### 匹配并捕获：`()  $1 $2`
### 非捕获匹配：`(?:...)  ?: ?= ?! ?<= ?<! `
先行后发断言都属于非捕获匹配。之前见过的都是用来匹配文本，这前后预查（零宽度断言）用来标记匹配文本的位置。它包含的**匹配本身并不返回**，而是用于**确定正确的匹配位置**，它本身不是匹配结果的一部分。
举个例子比较好理解：在 html 页面中提取 head 标签里面的内容，但是不想要标签内容，如下内容中，只想要`<title>`标签内内的内容作为匹配项，但是不想要`<title>`标签
- 正确：`(?<=<title>).*(?=</title>)`，结果：` Hi,This is my RE Note`
- 错误：`<title>.*</title>`，结果：`<title> Hi,This is my RE Note</title>`
```html
<head>
	<title> Hi,This is my RE Note</title>
</head>
<body>
	<h1> Hi,This is my RE Note </h1>
</body>
```
- `(?:..)`只组合不捕获
- `(?=pattern)`正先行断言-**存在**，表示第一部分表达式之后一定跟着pattern定义的原子
- `(?!pattern)`负先行断言-**排除**，与?=相反
- `(?<=pattern)`正后发断言-**存在** ，表示第一部分表达式之前一定跟着pattern定义的原子
- `(?<!pattern)`负后发断言-**排除**，与?\<=相反
### 控制标记：`(?a) (?!) (?g) (?L) (?m) (?s) (?x)`

[2]:	https://regexper.com/
[3]:	https://regex101.com/